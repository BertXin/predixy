# Predixy - 高性能Redis集群代理服务

## 项目概述

Predixy是一个用Go语言重构的高性能Redis集群代理服务，基于redis-cluster-proxy的设计理念，提供智能路由、自动重定向和集群感知功能。代理服务直接连接Redis集群节点，为客户端提供简化的单点访问接口。

## 使用场景

本项目专为以下高并发场景设计：
- **集群规模**: 9主9从的Redis Cluster集群
- **客户端连接**: 100个长连接
- **性能要求**: 每秒4万QPS的读写操作
- **网络架构**: 将内网Redis集群代理为公网访问接口
- **稳定性**: 高可用、连接复用、故障自动恢复

## 核心特性

### 🚀 高性能架构
- **多线程并发**: 基于Goroutine的高并发处理
- **连接池管理**: 智能连接复用和池化管理
- **零拷贝优化**: 减少内存分配和数据拷贝
- **异步I/O**: 非阻塞网络处理

### 🎯 智能路由
- **CRC16哈希槽**: 精确的键值路由算法
- **节点发现**: 自动发现和更新集群拓扑
- **负载均衡**: 读写分离和负载分散
- **故障转移**: 自动检测节点故障并重路由

### 🔄 自动重定向
- **MOVED处理**: 自动处理槽位迁移
- **ASK处理**: 处理临时重定向
- **集群重配置**: 动态更新集群配置
- **请求重试**: 智能重试机制

### 🛡️ 可靠性保障
- **健康检查**: 定期检测节点健康状态
- **连接恢复**: 自动重连断开的节点
- **请求排队**: 优雅处理网络抖动
- **监控指标**: 详细的性能和错误指标

## 架构设计

### 核心模块

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Client Pool   │    │  Protocol Parser │    │  Command Router │
│   客户端连接池    │────│   协议解析器     │────│   命令路由器     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ Connection Pool │    │ Cluster Manager │    │ Response Handler│
│   连接池管理     │────│   集群管理器     │────│   响应处理器     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Redis Cluster Nodes                         │
│                      Redis集群节点                              │
└─────────────────────────────────────────────────────────────────┘
```

### 数据流处理

1. **请求接收**: 客户端连接通过TCP连接发送Redis命令
2. **协议解析**: 解析RESP协议，提取命令和参数
3. **路由计算**: 根据键值计算哈希槽，确定目标节点
4. **连接复用**: 从连接池获取到目标节点的连接
5. **命令转发**: 将命令转发到对应的Redis节点
6. **响应处理**: 处理节点响应，包括重定向和错误处理
7. **结果返回**: 将最终结果返回给客户端

## 性能优化策略

### 网络层优化
- **连接复用**: 每个节点维护连接池，避免频繁建连
- **批量处理**: 支持pipeline和批量命令处理
- **内存池**: 预分配缓冲区，减少GC压力
- **零拷贝**: 使用splice等系统调用减少数据拷贝

### 并发优化
- **Goroutine池**: 限制并发数，避免过度创建
- **无锁设计**: 使用原子操作和channel通信
- **分片锁**: 减少锁竞争，提高并发性能
- **异步处理**: 非阻塞I/O和异步响应处理

### 内存优化
- **对象池**: 复用频繁创建的对象
- **缓冲区复用**: 复用读写缓冲区
- **压缩存储**: 优化内存布局和数据结构
- **GC调优**: 合理设置GC参数

## 监控和运维

### 性能指标
- **QPS/TPS**: 每秒请求数和事务数
- **延迟分布**: P50/P95/P99延迟统计
- **连接数**: 客户端和后端连接数
- **错误率**: 各类错误的统计

### 健康检查
- **节点状态**: 实时监控集群节点状态
- **连接健康**: 检测连接可用性
- **内存使用**: 监控内存使用情况
- **CPU负载**: 监控CPU使用率

## 配置说明

### 基础配置
```yaml
server:
  port: 6379              # 代理监听端口
  bind: "0.0.0.0"         # 绑定地址
  max_clients: 10000      # 最大客户端连接数
  
cluster:
  entry_points:           # 集群入口节点
    - "10.0.1.1:6379"
    - "10.0.1.2:6379"
    - "10.0.1.3:6379"
  
pool:
  size: 100               # 每个节点的连接池大小
  min_idle: 10            # 最小空闲连接数
  max_idle: 50            # 最大空闲连接数
  
performance:
  worker_threads: 8       # 工作线程数
  buffer_size: 4096       # 缓冲区大小
  batch_size: 100         # 批处理大小
```

## 快速开始

### 编译安装
```bash
# 克隆项目
git clone https://github.com/your-org/predixy.git
cd predixy

# 编译
go build -o predixy ./cmd/predixy

# 运行
./predixy -c config.yaml
```

### Docker部署
```bash
# 构建镜像
docker build -t predixy:latest .

# 运行容器
docker run -d -p 6379:6379 -v ./config.yaml:/etc/predixy/config.yaml predixy:latest
```

## 性能测试

在9主9从Redis集群环境下的性能测试结果：

| 指标 | 值 |
|------|----|
| 最大QPS | 45,000+ |
| 平均延迟 | < 1ms |
| P99延迟 | < 5ms |
| 内存使用 | < 500MB |
| CPU使用率 | < 30% |

## 贡献指南

欢迎提交Issue和Pull Request来改进项目。请确保：
1. 代码符合Go语言规范
2. 添加必要的单元测试
3. 更新相关文档
4. 通过所有CI检查

## 许可证

本项目采用MIT许可证，详见[LICENSE](LICENSE)文件。